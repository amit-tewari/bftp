-> ## Files and Processes
-> ## ...................

-> Computing is all about processing data
^

-> Two core concepts
^

-> * Files *
^
-> and
-> * Processes *

---

-> ## Processes
-> ## .........

-> (almost) Anything, not a file, is a process.

^
- shell is the process we interact with.
^
- running editors, web-browsers are also processes.
^
- processes are like living entities. processes
  - have identity
  - create child
  - die
  - communicate
  - even sleep ðŸ˜‰
^
- Unlike living enities
  - processes change their code after start

^
-> Just like root i-node, we have special process with ID 1.

---

-> ## init and systemd
-> ## ................

init
....
- is *initial* process
- is started during boot
- creates other main processes in process tree
- usually has process ID 1

^
-> systemd is modern init system
-> .............................

-> try *pstree -p* on console

---

-> ## Input, Output and Error
-> ## .......................

Processes
- read input
- write output

^
- have 3 standard *streams*, available by default
  - *STDIN* : read _buffered_ input from
  - *STDOUT* : write buffered output to
  - *STDERR* : write _un-buffered_ errors to

^
Buffering
- collect data from multiple operations before performing I/O
- improves throughput and I/O efficiency
- reduces interactivity

---

-> ## Process table and File descriptor tables
-> ## ........................................

Process Table
- array of *Process ID (PID)* and *Process Control Block (PCB)* tuples

Process Control Block consists of
- Process ID
- Parent process ID
- Process Group ID
- Instruction pointer
- Memory maps
- Open file descriptors -> File descriptor table (FDT)
- Priority and scheduling information
- Resource counters
- Much more information

File Descriptor table
- Per process
- file open mode
- read and/ or write pointers
- pointer into *Global file descriptor table*

---

-> ## Global file descriptor table (GFDT)
-> ## ...................................

GFDT contains
- in-core inode for each opened file
- reference count for each file from PCB file descriptor table

FDT1                    | GFDT
....                    | 1: fileX (2)
FD3:R=100,W=100:GFDT(1) | 2: fileY (1)
FD4:R=50,W=50:GFDT(2)   | 3: fileZ (1)
                        |
FDT2                    |
....                    |
FD3:R=100,W=100:GFDT(3) |
FD4:R=50,W=50:GFDT(1)   |

---

-> ## Process creation: fork()/ exec()
-> ## ................................

- Processes create children using *fork* library call
- A process changes program text using *exec* library call
^
- Certain customizations happen between fork and exec
  - open/ close/ duplicate file FDs
  - open/ close/ duplicate pipes FDs
  - tweak environment variables, etc.

---

-> ## fork & exec example
-> ## ...................

-> Simplified explanation for *ls | sort*

- shell creates a *pipe (|)*
- shell forks two process
- Both processes now share the pipe
^
- First process
  - closes STDOUT file descriptor
  - duplicates pipe's write file descriptor to STDOUT
  - exec code from *ls* binary
^
- Second process
  - closes STDIN file descriptor
  - duplicates pipe's read file descriptor to STDIN
  - exec code from *sort* binary

---
-> ## Process States
-> ## ..............

- *D* = uninterruptible sleep
- *I* = idle
- *R* = running
- *S* = sleeping
- *T* = stopped by job control signal
- *t* = stopped by debugger during trace
- *Z* = zombie

^
-> Commands
-> ........

-> ps
-> top

---
-> ## I/O Redirction and Pipelining
-> ## .............................

by default
- STDIN connects to keybord input
- STDOUT and STDERR connect to display

^
Redirection
- allows STD{IN,OUT,ERR} streams to connect to files
-  *<* = STDIN redirection
-  *>* = STDOUT redirection, with *truncate*
- *>>* = STDOUT redirection, with *append*
- *2>* = STDERR redirection
^
- e.g.
  - *$ cat < infile > outfile 2> errorfile*
  - *$ cat < infile >> outfile*

^
Pipeline
- connects STDOUT of one process into STDIN of another
^
- processes need to have a common ancestor
^
- e.g.
  - *$ cat | sort*
